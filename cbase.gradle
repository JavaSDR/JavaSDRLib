import groovy.transform.Field
import org.gradle.internal.jvm.Jvm

import java.nio.file.Files

apply plugin: "cpp"

@Field
private Map<String, List<String>> clibs = new HashMap<>()
@Field
private Map<String, String[]> extraLibz = new HashMap<>()
List<String> packages = new ArrayList<>()
@Field
Map<String, Map<String, String> > outLibs = new HashMap<>()
List<String> ccppl = new ArrayList<>()

configurations {
    javacpp
    compile {
        extendsFrom javacpp
    }
}

gradle.taskGraph.whenReady({graph ->
    if (configurations.javacpp.allDependencies.empty) {
        throw new IllegalStateException("JavaCPP not configured!")
    }
})

task generateCPP {
    dependsOn compileJava
    it.metaClass.generateCPPCode << {
        jni_package, jni_class, libName, platforms_ ->
            jni_package = jni_package.replace(".", "/")
            String jniDLL = "jni" + jni_class
            packages.add(jni_package)
            ccppl.add("${jni_package}/${jni_class}#${jniDLL}")
            addNativeInternal(jni_package, libName, jniDLL, platforms_, true)
    }
    it.metaClass.generateExistingCPPCode << {
        jni_package, jni_class, libName, platforms_ ->
            jni_package = jni_package.replace(".", "/")
            String jniDLL = "jni" + jni_class
            packages.add(jni_package)
            ccppl.add("${jni_package}/${jni_class}#${jniDLL}")
            addNativeInternal(jni_package, libName, jniDLL, platforms_, false)
    }
    doFirst {
        for (File file : new File(projectDir.absolutePath + "/src/main/cpp/generated").listFiles()) {
            if (file.isDirectory()) {
                for (File file2 : file.listFiles()) {
                    file2.delete()
                }
            }
            file.delete()
        }
        for (String nam : ccppl) {
            String[] prt = nam.split('#')
            javaexec {
                main = 'org.bytedeco.javacpp.tools.Builder'
                classpath = files(configurations.javacpp.asPath)
                //noinspection GroovyAssignabilityCheck
                args '-cp', compileJava.destinationDir.absolutePath,
                        "-nocompile",
                        "-d", projectDir.absolutePath + "/src/main/cpp/generated/" + prt[1],
                        prt[0]
            }
        }
    }
}

task compileCPre {
    dependsOn generateCPP
}

task compileC {
    dependsOn generateCPP
    dependsOn compileCPre
    doLast {
        println "Compiled native code"
    }
}

task generateJNI {
    dependsOn compileC

    doLast {
        println "Copying native files"
        for (String pack : packages) {
            Map<String, String> mawp = outLibs.get(pack)
            if (mawp == null) {
                mawp = new HashMap<>()
            }
            for (String s : new HashSet<>(mawp.values())) {
                File destFolder = new File(compileJava.destinationDir, "${pack}/${s}")
                if (destFolder.exists()) {
                    for (File file : destFolder.listFiles()) {
                        file.delete()
                    }
                    destFolder.delete()
                }
                destFolder.mkdirs()
            }
            Set<String> check = new HashSet<>()
            for (String s : mawp.keySet()) {
                String platform = mawp.get(s)
                String fileName = s.substring(s.lastIndexOf(File.separator) + 1)
                String ext = fileName.substring(fileName.lastIndexOf('.'))
                File destBase = new File(compileJava.destinationDir, "${pack}/${platform}")
                File orig = new File(s)
                File dest = new File(destBase, fileName)
                Files.copy(orig.toPath(), dest.toPath())
                if (check.add(platform)) {
                    for (String cn : ["", pack]) {
                        for (String dep : clibs.get(cn)) {
                            File ori = new File(projectDir, "clibs/" + dep + File.separator + platform + File.separator + dep + ext)
                            if (!ori.exists()) {
                                continue
                            }
                            File des = new File(destBase, dep + ext)
                            Files.copy(ori.toPath(), des.toPath())
                        }
                    }
                }
            }

        }
    }
}

classes.dependsOn generateJNI

dependencies {
    it.metaClass.addCLibrary << {
        String name ->
            if (!clibs.containsKey("")) {
                clibs.put("", new ArrayList<String>())
            }
            clibs.get("").add name
    }
    it.metaClass.addCLibrary << {
        String pack, String name ->
            pack = pack.replace(".", "/")
            if (!clibs.containsKey(pack)) {
                clibs.put(pack, new ArrayList<String>())
            }
            clibs.get(pack).add name
    }
    it.metaClass.addInstalledCLibrary << {
        String sysVal ->
            addInstalledCLibrary(sysVal, "bin", "lib", "include")
    }
}

private void addInstalledCLibrary(String sysVal, String bin, String lib, String include) {
    //extraLibz.put(System.getenv(sysVal), new String[] {bin, lib, include})
}

project.afterEvaluate {
    project -> modelRegistry.realize('components', ModelMap)
}

private void addNativeInternal(pack, libName, jniLibName, platforms_, boolean compInternal) {
    if (outLibs.get(pack) == null) {
        outLibs.put(pack, new HashMap())
    }
    Object platformz = platforms_
    if (platformz instanceof String) {
        platformz = [platformz]
    }
    File folc = new File(projectDir, "/src/main/cpp/generated/${libName}")
    if (!folc.exists()) {
        folc.mkdirs()
    }
    model {
        components {
            if (compInternal) {
                "${libName}"(NativeLibrarySpec) {
                    for (String platform : platformz) {
                        targetPlatform platform
                    }
                    Object head
                    sources {
                        cpp {
                            source {
                                srcDir projectDir.absolutePath + "/src/main/c/${libName}"
                                srcDir projectDir.absolutePath + "/src/main/c/common"
                            }
                            exportedHeaders {
                                head = it
                                addHeaders(it, pack, libName)
                            }
                        }
                    }
                    binaries.all {
                        setArgs(linker, cCompiler, targetPlatform, head, false, null)
                        if (getDisplayName().startsWith("shared")) {
                            outLibs.get(pack).put(primaryOutput.absolutePath, getFolderName(targetPlatform))
                            String upName = name.substring(0, 1).toUpperCase() + name.substring(1)
                            project.tasks.compileCPre.dependsOn(libName + upName)
                            project.tasks.compileC.dependsOn(jniLibName + upName)
                        }
                    }
                }
            }
            "${jniLibName}"(NativeLibrarySpec) {
                for (String platform : platformz) {
                    targetPlatform platform
                }
                Object head
                sources {
                    cpp {
                        source {
                            println projectDir.absolutePath + "/src/main/cpp/generated/${jniLibName}"
                            srcDir projectDir.absolutePath + "/src/main/cpp/generated/${jniLibName}"
                        }
                        exportedHeaders {
                            head = it
                            addHeaders(it, pack, libName)
                        }
                    }
                }
                binaries.all {
                    if (getDisplayName().startsWith("shared")) {
                        outLibs.get(pack).put(primaryOutput.absolutePath, getFolderName(targetPlatform))
                    }
                    String linkName = primaryOutput.absolutePath
                            .replace(projectDir.absolutePath + File.separator, "")
                            .replace(jniLibName, libName)
                    linkName = linkName.substring(0, linkName.lastIndexOf(libName)) + libName + ".lib"
                    setArgs(linker, cppCompiler, targetPlatform, head, true, linkName)
                }
            }
        }
    }
}

void addHeaders(srcManager, pack, libName) {
    srcManager.srcDir projectDir.absolutePath + "/src/main/c/${libName}/headers"
    srcManager.srcDir projectDir.absolutePath + "/src/main/c/common/headers"
    for (String p : ["", pack]) {
        for (String s : clibs.get(p)) {
            srcManager.srcDir projectDir.absolutePath + "/clibs/" + s + "/include"
        }
    }
}

void setArgs(linker, compiler, targetPlatform, headers, boolean cpp, libName_) {
    if (targetPlatform.operatingSystem.macOsX) {
        headers.srcDir "${Jvm.current().javaHome}/include"
        headers.srcDir "${Jvm.current().javaHome}/include/darwin"
        compiler.args '-mmacosx-version-min=10.4'
        linker.args '-mmacosx-version-min=10.4'
    } else if (targetPlatform.operatingSystem.linux) {
        headers.srcDir "${Jvm.current().javaHome}/include"
        headers.srcDir "${Jvm.current().javaHome}/include/linux"
        compiler.args '-D_FILE_OFFSET_BITS=64'
    } else if (targetPlatform.operatingSystem.windows) {
        headers.srcDir "${Jvm.current().javaHome}/include"
        headers.srcDir "${Jvm.current().javaHome}/include/win32"
        linker.args "Shlwapi.lib", "Advapi32.lib"
    } else if (targetPlatform.operatingSystem.freeBSD) {
        headers.srcDir "${Jvm.current().javaHome}/include"
        headers.srcDir "${Jvm.current().javaHome}/include/freebsd"
    }
    compiler.args '-std=c++0x'
    compiler.args '-pthread'
    for (List<String> libz : clibs.values()) {
        for (String s : libz) {
            String folderBase = "clibs/" + s + "/" + getFolderName(targetPlatform)
            if (project.file(folderBase).exists()) {
                linker.args folderBase + "/" + s + ".lib"
            }
        }
    }
    for (String s : extraLibz.keySet()) {
        File folder = new File(s + "/" + extraLibz.get(s)[1])
        for (File fil : folder.listFiles()) {
            if (fil.absolutePath.endsWith(".lib")) {
                linker.args fil.absolutePath
            }
        }
    }
    if (cpp) {
        linker.args libName_
    }
}

@SuppressWarnings("all")
private static String getFolderName(targetPlatform) {
    Object os = targetPlatform.properties.operatingSystem
    Object platform = targetPlatform.properties.architecture

    String osName
    String archName
    if (os.windows) {
        osName = "windows"
    } else if (os.linux) {
        osName = "linux"
    } else if (os.solaris) {
        throw new UnsupportedOperationException()
    } else if (os.macOsX) {
        osName = "macosx"
    } else if (os.freeBSD) {
        throw new UnsupportedOperationException()
    }

    if (platform.amd64) {
        archName = "x86_64"
    } else if (platform.arm) {
        archName = "arm64"
    } else if (platform.i386) {
        archName = "x86"
    } else if (platform.ia64) { //Get out
        throw new UnsupportedOperationException()
    }

    return osName + "-" + archName
}
